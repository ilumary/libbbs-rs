use bls12_381::{
    multi_miller_loop, G1Affine, G1Projective, G2Affine, G2Prepared, G2Projective, Gt, Scalar,
};
use sha2::{Digest, Sha256};

const BBS_DST: &[u8] = b"BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_";

const H_INPUT_BLOCK_SIZE: usize = 64;
const H_OUTPUT_BLOCK_SIZE: usize = 32;
const EXPAND_LEN: usize = 48;
const OCTET_SCALAR_LENGTH: usize = 32;
const P1_COMPRESSED: [u8; 48] = [
    0xa8, 0xce, 0x25, 0x61, 0x02, 0x84, 0x08, 0x21, 0xa3, 0xe9, 0x4e, 0xa9, 0x02, 0x5e, 0x46, 0x62,
    0xb2, 0x05, 0x76, 0x2f, 0x97, 0x76, 0xb3, 0xa7, 0x66, 0xc8, 0x72, 0xb9, 0x48, 0xf1, 0xfd, 0x22,
    0x5e, 0x7c, 0x59, 0x69, 0x85, 0x88, 0xe7, 0x0d, 0x11, 0x40, 0x6d, 0x16, 0x1b, 0x4e, 0x28, 0xc9,
];

pub fn verify(pk: &[u8], signature: &mut [u8], header: Option<&[u8]>, messages: &[&[u8]]) -> bool {
    let header = header.unwrap_or(&[]);
    let api_id = [BBS_DST, b"H2G_HM2S_"].concat();

    let message_scalars = messages_to_scalars(messages, Some(&api_id));
    let generators = create_generators(messages.len() + 1, Some(&api_id));

    signature[48..80].reverse();
    let (a, e) = (
        G1Affine::from_compressed(signature[..48].try_into().unwrap()).unwrap(),
        Scalar::from_bytes(signature[48..80].try_into().unwrap()).unwrap(),
    );
    let w = G2Affine::from_compressed(&pk.try_into().unwrap()).unwrap();

    let l = message_scalars.len();
    assert!(
        l + 1 == generators.len(),
        "generators and messages dont match"
    );
    let q_1 = generators[0];
    let h = &generators[1..];

    let domain = calculate_domain(pk, &q_1, h, Some(header), Some(&api_id));

    // B = P1 + Q_1 * domain + H_1 * msg_1 + ... + H_L * msg_L
    let affine_q_1: G1Affine = (&q_1).into();
    let p_1: G1Affine = G1Affine::from_compressed(&P1_COMPRESSED).unwrap();
    let b: G1Projective = h
        .iter()
        .zip(message_scalars.iter())
        .fold(p_1 + affine_q_1 * domain, |acc: G1Projective, (h, m)| {
            acc + h * m
        });

    // if h(A, W) * h(A * e - B, BP2) != Identity_GT
    compaire_pairing(
        &[
            (&a, &G2Prepared::from(w)),
            (
                &G1Affine::from(a * e - b),
                &G2Prepared::from(G2Affine::generator()),
            ),
        ],
        &Gt::identity(),
    )
}

pub fn sign(sk: Scalar, pk: &[u8], header: Option<&[u8]>, messages: &[&[u8]]) -> Vec<u8> {
    let header = header.unwrap_or(&[]);
    let api_id = [BBS_DST, b"H2G_HM2S_"].concat();

    let message_scalars = messages_to_scalars(messages, Some(&api_id));
    let generators = create_generators(messages.len() + 1, Some(&api_id));

    // core sign
    let hash_to_scalar_dst = [api_id.as_slice(), b"H2S_"].concat();
    let l = message_scalars.len();

    assert!(
        l + 1 == generators.len(),
        "generators and messages dont match"
    );
    let q_1 = generators[0];
    let h = &generators[1..];

    let domain = calculate_domain(pk, &q_1, h, Some(header), Some(&api_id));

    // serialize((SK, msg_1, ..., msg_L, domain))
    let mut octs = Vec::new();
    serialize_scalar(&mut octs, &sk);
    for msg in &message_scalars {
        serialize_scalar(&mut octs, msg);
    }
    serialize_scalar(&mut octs, &domain);

    // e = hash_to_scalar(serialize((SK, msg_1, ..., msg_L, domain)), hash_to_scalar_dst)
    let e = hash_to_scalar(&octs, &hash_to_scalar_dst);

    // B = P1 + Q_1 * domain + H_1 * msg_1 + ... + H_L * msg_L
    let affine_q_1: G1Affine = (&q_1).into();
    let p_1: G1Affine = G1Affine::from_compressed(&P1_COMPRESSED).unwrap();
    let b: G1Projective = h
        .iter()
        .zip(message_scalars.iter())
        .fold(p_1 + affine_q_1 * domain, |acc: G1Projective, (h, m)| {
            acc + h * m
        });

    // A = B * (1 / (SK + e))
    let a: G1Affine = (b * (sk + e).invert().unwrap()).into();

    signature_to_octets(&a, &e)
}

fn compaire_pairing(bilinear_maps: &[(&G1Affine, &G2Prepared)], result: &Gt) -> bool {
    multi_miller_loop(bilinear_maps).final_exponentiation() == *result
}

fn signature_to_octets(a: &G1Affine, e: &Scalar) -> Vec<u8> {
    // Serialize A (G1 point) in compressed form (48 bytes)
    let a_bytes = a.to_compressed();

    // Serialize e (scalar) as 32 bytes, must reverse because Scalar is little endianess
    let mut bytes = e.to_bytes();
    bytes.reverse();
    assert!(
        bytes.len() <= OCTET_SCALAR_LENGTH,
        "value too large to be serialized"
    );

    let mut e_bytes = [0u8; OCTET_SCALAR_LENGTH];
    let start = OCTET_SCALAR_LENGTH - bytes.len();
    e_bytes[start..].copy_from_slice(&bytes);

    // Concatenate: A || e (48 + 32 = 80 bytes total)
    [&a_bytes[..], &e_bytes[..]].concat()
}

fn calculate_domain(
    pk: &[u8],
    q_1: &G1Projective,
    h_points: &[G1Projective],
    header: Option<&[u8]>,
    api_id: Option<&[u8]>,
) -> Scalar {
    let api_id = api_id.unwrap_or(&[]);
    let header = header.unwrap_or(&[]);

    let hash_to_scalar_dst = [api_id, b"H2S_"].concat();

    let l = h_points.len();

    // dom_array = (L, Q_1, H_1, ..., H_L)
    // dom_octs = serialize(dom_array) || api_id
    let mut dom_octs = Vec::new();
    dom_octs.extend_from_slice(&(l as u64).to_be_bytes());

    serialize_g1_point(&mut dom_octs, q_1.into());

    for h in h_points {
        serialize_g1_point(&mut dom_octs, h.into());
    }

    dom_octs.extend_from_slice(api_id);

    // dom_input = PK || dom_octs || I2OSP(length(header), 8) || header
    let header_len = (header.len() as u64).to_be_bytes();
    let dom_input = [pk, &dom_octs[..], &header_len[..], header].concat();

    // return hash_to_scalar(dom_input, hash_to_scalar_dst)
    hash_to_scalar(&dom_input, &hash_to_scalar_dst)
}

/// serializes a G2Affine into out
fn serialize_g2_point(out: &mut Vec<u8>, g2_point: G2Affine) {
    out.extend_from_slice(&g2_point.to_compressed());
}

/// serializes a G1Affine into out
fn serialize_g1_point(out: &mut Vec<u8>, g1_point: G1Affine) {
    out.extend_from_slice(&g1_point.to_compressed());
}

/// serializes a scalar value. Scalar::to_bytes return little endian, so we have to reverse
fn serialize_scalar(out: &mut Vec<u8>, scalar: &Scalar) {
    let start = out.len();
    out.extend_from_slice(&scalar.to_bytes());
    out[start..].reverse();
}

fn create_generators(count: usize, api_id: Option<&[u8]>) -> Vec<G1Projective> {
    let api_id = api_id.unwrap_or(&[]);

    let seed_dst = [api_id, b"SIG_GENERATOR_SEED_"].concat();
    let generator_dst = [api_id, b"SIG_GENERATOR_DST_"].concat();
    let generator_seed = [api_id, b"MESSAGE_GENERATOR_SEED"].concat();

    let mut generators = Vec::with_capacity(count);

    let mut v = expand_message_xmd(&generator_seed, &seed_dst, EXPAND_LEN);

    for i in 1..=count {
        let i_bytes = (i as u64).to_be_bytes();
        let input = [&v[..], &i_bytes].concat();
        v = expand_message_xmd(&input, &seed_dst, EXPAND_LEN);

        let generator_i = hash_to_curve_g1(&v, &generator_dst);
        generators.push(generator_i);
    }

    generators
}

fn hash_to_curve_g1(msg: &[u8], dst: &[u8]) -> G1Projective {
    use bls12_381::hash_to_curve::{ExpandMsgXmd, HashToCurve};

    <G1Projective as HashToCurve<ExpandMsgXmd<sha2::Sha256>>>::hash_to_curve(msg, dst)
}

fn messages_to_scalars(messages: &[&[u8]], api_id: Option<&[u8]>) -> Vec<Scalar> {
    // ABORT if length(messages) > 2^64 - 1
    // This is automatically satisfied since Vec can't exceed usize::MAX
    // which is at most 2^64 - 1 on 64-bit systems

    let api_id = api_id.unwrap_or(&[]);

    let map_dst = [api_id, b"MAP_MSG_TO_SCALAR_AS_HASH_"].concat();

    let msg_scalars: Vec<Scalar> = messages
        .iter()
        .map(|msg| hash_to_scalar(msg, &map_dst))
        .collect();

    msg_scalars
}

pub fn sk_to_pk(sk: &Scalar) -> Vec<u8> {
    let w = G2Projective::generator() * sk;

    point_to_octets_e2(&w)
}

fn point_to_octets_e2(point: &G2Projective) -> Vec<u8> {
    let affine: G2Affine = point.into();
    affine.to_compressed().to_vec()
}

pub fn key_gen(key_material: &[u8], key_info: &[u8], key_dst: Option<&[u8]>) -> Scalar {
    assert!(key_material.len() >= 32, "key_material is too short");
    assert!(key_info.len() <= 65535, "key_info is too long");

    let default_dst;
    let key_dst = if let Some(dst) = key_dst {
        dst
    } else {
        default_dst = [BBS_DST, b"KEYGEN_DST_"].concat();
        &default_dst
    };

    let key_info_len = (key_info.len() as u16).to_be_bytes().to_vec();
    let derive_input = [key_material, &key_info_len, key_info].concat();

    hash_to_scalar(&derive_input, key_dst)
}

fn hash_to_scalar(msg_octets: &[u8], dst: &[u8]) -> Scalar {
    assert!(dst.len() <= 255, "DST too long");

    let uniform_bytes = expand_message_xmd(msg_octets, dst, EXPAND_LEN);

    // convert endianess
    let mut wide_bytes = [0u8; 64];
    wide_bytes[16..].copy_from_slice(&uniform_bytes);
    wide_bytes.reverse();

    Scalar::from_bytes_wide(&wide_bytes)
}

/// RFC 9380 sec. 5.3.1 expand_message_xmd()
pub fn expand_message_xmd(msg: &[u8], dst: &[u8], len_in_bytes: usize) -> Vec<u8> {
    let s_in_bytes = H_INPUT_BLOCK_SIZE;
    let b_in_bytes = H_OUTPUT_BLOCK_SIZE;

    let ell = len_in_bytes.div_ceil(b_in_bytes);

    assert!(ell <= 255, "ell > 255");
    assert!(len_in_bytes <= 65535, "len_in_bytes > 65535");
    assert!(dst.len() <= 255, "DST too long");

    let dst_prime = {
        let mut v = Vec::from(dst);
        v.push(dst.len() as u8);
        v
    };

    let z_pad = vec![0u8; s_in_bytes];
    let l_i_b_str = (len_in_bytes as u16).to_be_bytes();

    let msg_prime = [&z_pad, msg, &l_i_b_str, &[0u8], &dst_prime].concat();

    let b0 = Sha256::digest(&msg_prime);

    let mut output = vec![0u8; ell * b_in_bytes];

    let mut hasher = Sha256::new();
    hasher.update(b0);
    hasher.update([0x01]);
    hasher.update(&dst_prime);
    let b_1 = hasher.finalize();
    output[0..H_OUTPUT_BLOCK_SIZE].copy_from_slice(&b_1);

    for i in 2..=ell {
        let mut xor_res = [0u8; H_OUTPUT_BLOCK_SIZE];
        for k in 0..32 {
            xor_res[k] = b0[k] ^ output[((i - 2) * H_OUTPUT_BLOCK_SIZE) + k];
        }

        let mut hasher = Sha256::new();
        hasher.update(xor_res);
        hasher.update([i as u8]);
        hasher.update(&dst_prime);
        let b_x = hasher.finalize();
        let off = (i - 1) * b_in_bytes;
        output[off..off + H_OUTPUT_BLOCK_SIZE].copy_from_slice(&b_x);
    }

    output.truncate(len_in_bytes);
    output
}

#[cfg(test)]
mod tests {
    use super::*;

    // test function used to convert big endian byte arrays into little endian and then Scalars
    fn bytes_be_to_scalar(bytes: &[u8; 32]) -> Scalar {
        let mut tmp = [0u8; 64];
        tmp[32..].copy_from_slice(bytes);
        tmp.reverse();
        Scalar::from_bytes_wide(&tmp)
    }

    pub const M1: &[u8] = &[
        0x98, 0x72, 0xad, 0x08, 0x9e, 0x45, 0x2c, 0x7b, 0x6e, 0x28, 0x3d, 0xfa, 0xc2, 0xa8, 0x0d,
        0x58, 0xe8, 0xd0, 0xff, 0x71, 0xcc, 0x4d, 0x5e, 0x31, 0x0a, 0x1d, 0xeb, 0xdd, 0xa4, 0xa4,
        0x5f, 0x02,
    ];
    pub const M2: &[u8] = &[
        0xc3, 0x44, 0x13, 0x6d, 0x9a, 0xb0, 0x2d, 0xa4, 0xdd, 0x59, 0x08, 0xbb, 0xba, 0x91, 0x3a,
        0xe6, 0xf5, 0x8c, 0x2c, 0xc8, 0x44, 0xb8, 0x02, 0xa6, 0xf8, 0x11, 0xf5, 0xfb, 0x07, 0x5f,
        0x9b, 0x80,
    ];
    pub const M3: &[u8] = &[
        0x73, 0x72, 0xe9, 0xda, 0xa5, 0xed, 0x31, 0xe6, 0xcd, 0x5c, 0x82, 0x5e, 0xac, 0x1b, 0x85,
        0x5e, 0x84, 0x47, 0x6a, 0x1d, 0x94, 0x93, 0x2a, 0xa3, 0x48, 0xe0, 0x7b, 0x73,
    ];
    pub const M4: &[u8] = &[
        0x77, 0xfe, 0x97, 0xeb, 0x97, 0xa1, 0xeb, 0xe2, 0xe8, 0x1e, 0x4e, 0x35, 0x97, 0xa3, 0xee,
        0x74, 0x0a, 0x66, 0xe9, 0xef, 0x24, 0x12, 0x47, 0x2c,
    ];
    pub const M5: &[u8] = &[
        0x49, 0x66, 0x94, 0x77, 0x4c, 0x56, 0x04, 0xab, 0x1b, 0x25, 0x44, 0xea, 0xba, 0xbc, 0xf0,
        0xf5, 0x32, 0x78, 0xff, 0x50,
    ];
    pub const M6: &[u8] = &[
        0x51, 0x5a, 0xe1, 0x53, 0xe2, 0x2a, 0xae, 0x04, 0xad, 0x16, 0xf7, 0x59, 0xe0, 0x72, 0x37,
        0xb4,
    ];
    pub const M7: &[u8] = &[
        0xd1, 0x83, 0xdd, 0xc6, 0xe2, 0x66, 0x5a, 0xa4, 0xe2, 0xf0, 0x88, 0xaf,
    ];
    pub const M8: &[u8] = &[0xac, 0x55, 0xfb, 0x33, 0xa7, 0x59, 0x09, 0xed];
    pub const M9: &[u8] = &[0x96, 0x01, 0x20, 0x96];
    pub const M10: &[u8] = &[];

    #[test]
    fn sign_multi_message() {
        let sk = bytes_be_to_scalar(&[
            0x60, 0xe5, 0x51, 0x10, 0xf7, 0x68, 0x83, 0xa1, 0x3d, 0x03, 0x0b, 0x2f, 0x6b, 0xd1,
            0x18, 0x83, 0x42, 0x2d, 0x5a, 0xbd, 0xe7, 0x17, 0x56, 0x9f, 0xc0, 0x73, 0x1f, 0x51,
            0x23, 0x71, 0x69, 0xfc,
        ]);

        let pk = [
            0xa8, 0x20, 0xf2, 0x30, 0xf6, 0xae, 0x38, 0x50, 0x3b, 0x86, 0xc7, 0x0d, 0xc5, 0x0b,
            0x61, 0xc5, 0x8a, 0x77, 0xe4, 0x5c, 0x39, 0xab, 0x25, 0xc0, 0x65, 0x2b, 0xba, 0xa8,
            0xfa, 0x13, 0x6f, 0x28, 0x51, 0xbd, 0x47, 0x81, 0xc9, 0xdc, 0xde, 0x39, 0xfc, 0x9d,
            0x1d, 0x52, 0xc9, 0xe6, 0x02, 0x68, 0x06, 0x1e, 0x7d, 0x76, 0x32, 0x17, 0x1d, 0x91,
            0xaa, 0x8d, 0x46, 0x0a, 0xce, 0xe0, 0xe9, 0x6f, 0x1e, 0x7c, 0x4c, 0xfb, 0x12, 0xd3,
            0xff, 0x9a, 0xb5, 0xd5, 0xdc, 0x91, 0xc2, 0x77, 0xdb, 0x75, 0xc8, 0x45, 0xd6, 0x49,
            0xef, 0x3c, 0x4f, 0x63, 0xae, 0xbc, 0x36, 0x4c, 0xd5, 0x5d, 0xed, 0x0c,
        ];

        let header = [
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0x00, 0xaa, 0xbb, 0xcc, 0xdd,
            0xee, 0xff,
        ];

        let expected_signature = [
            0x83, 0x39, 0xb2, 0x85, 0xa4, 0xac, 0xd8, 0x9d, 0xec, 0x77, 0x77, 0xc0, 0x95, 0x43,
            0xa4, 0x3e, 0x3c, 0xc6, 0x06, 0x84, 0xb0, 0xa6, 0xf8, 0xab, 0x33, 0x5d, 0xa4, 0x82,
            0x5c, 0x96, 0xe1, 0x46, 0x3e, 0x28, 0xf8, 0xc5, 0xf4, 0xfd, 0x06, 0x41, 0xd1, 0x9c,
            0xec, 0x59, 0x20, 0xd3, 0xa8, 0xff, 0x4b, 0xed, 0xb6, 0xc9, 0x69, 0x14, 0x54, 0x59,
            0x7b, 0xbd, 0x29, 0x82, 0x88, 0xab, 0xed, 0x36, 0x32, 0x07, 0x85, 0x57, 0xb2, 0xac,
            0xe7, 0xd4, 0x4c, 0xae, 0xd8, 0x46, 0xe1, 0xa0, 0xa1, 0xe8,
        ];

        let mut signature = sign(
            sk,
            &pk,
            Some(&header),
            &[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10],
        );

        assert_eq!(signature, expected_signature);

        let result = verify(
            &pk,
            &mut signature,
            Some(&header),
            &[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10],
        );

        assert!(result);
    }

    #[test]
    fn sign_single_message() {
        let msg = [
            0x98, 0x72, 0xad, 0x08, 0x9e, 0x45, 0x2c, 0x7b, 0x6e, 0x28, 0x3d, 0xfa, 0xc2, 0xa8,
            0x0d, 0x58, 0xe8, 0xd0, 0xff, 0x71, 0xcc, 0x4d, 0x5e, 0x31, 0x0a, 0x1d, 0xeb, 0xdd,
            0xa4, 0xa4, 0x5f, 0x02,
        ];

        let sk = bytes_be_to_scalar(&[
            0x60, 0xe5, 0x51, 0x10, 0xf7, 0x68, 0x83, 0xa1, 0x3d, 0x03, 0x0b, 0x2f, 0x6b, 0xd1,
            0x18, 0x83, 0x42, 0x2d, 0x5a, 0xbd, 0xe7, 0x17, 0x56, 0x9f, 0xc0, 0x73, 0x1f, 0x51,
            0x23, 0x71, 0x69, 0xfc,
        ]);

        let pk = [
            0xa8, 0x20, 0xf2, 0x30, 0xf6, 0xae, 0x38, 0x50, 0x3b, 0x86, 0xc7, 0x0d, 0xc5, 0x0b,
            0x61, 0xc5, 0x8a, 0x77, 0xe4, 0x5c, 0x39, 0xab, 0x25, 0xc0, 0x65, 0x2b, 0xba, 0xa8,
            0xfa, 0x13, 0x6f, 0x28, 0x51, 0xbd, 0x47, 0x81, 0xc9, 0xdc, 0xde, 0x39, 0xfc, 0x9d,
            0x1d, 0x52, 0xc9, 0xe6, 0x02, 0x68, 0x06, 0x1e, 0x7d, 0x76, 0x32, 0x17, 0x1d, 0x91,
            0xaa, 0x8d, 0x46, 0x0a, 0xce, 0xe0, 0xe9, 0x6f, 0x1e, 0x7c, 0x4c, 0xfb, 0x12, 0xd3,
            0xff, 0x9a, 0xb5, 0xd5, 0xdc, 0x91, 0xc2, 0x77, 0xdb, 0x75, 0xc8, 0x45, 0xd6, 0x49,
            0xef, 0x3c, 0x4f, 0x63, 0xae, 0xbc, 0x36, 0x4c, 0xd5, 0x5d, 0xed, 0x0c,
        ];

        let header = [
            0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0x00, 0xaa, 0xbb, 0xcc, 0xdd,
            0xee, 0xff,
        ];

        let expected_signature = [
            0x84, 0x77, 0x31, 0x60, 0xb8, 0x24, 0xe1, 0x94, 0x07, 0x3a, 0x57, 0x49, 0x3d, 0xac,
            0x1a, 0x20, 0xb6, 0x67, 0xaf, 0x70, 0xcd, 0x23, 0x52, 0xd8, 0xaf, 0x24, 0x1c, 0x77,
            0x65, 0x8d, 0xa5, 0x25, 0x3a, 0xa8, 0x45, 0x83, 0x17, 0xcc, 0xa0, 0xea, 0xe6, 0x15,
            0x69, 0x0d, 0x55, 0xb1, 0xf2, 0x71, 0x64, 0x65, 0x7d, 0xca, 0xfe, 0xe1, 0xd5, 0xc1,
            0x97, 0x39, 0x47, 0xaa, 0x70, 0xe2, 0xcf, 0xbb, 0x4c, 0x89, 0x23, 0x40, 0xbe, 0x59,
            0x69, 0x92, 0x0d, 0x09, 0x16, 0x06, 0x7b, 0x45, 0x65, 0xa0,
        ];

        let mut signature = sign(sk, &pk, Some(&header), &[&msg]);

        assert_eq!(signature, expected_signature);

        let result = verify(&pk, &mut signature, Some(&header), &[&msg]);

        assert!(result);
    }

    #[test]
    fn create_generators_test_vec_1() {
        let input_count = 11;
        let api_id = b"BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_H2G_HM2S_";

        let generators = create_generators(input_count, Some(api_id));

        let q1 = [
            0xa9, 0xec, 0x65, 0xb7, 0x0a, 0x7f, 0xbe, 0x40, 0xc8, 0x74, 0xc9, 0xeb, 0x04, 0x1c,
            0x2c, 0xb0, 0xa7, 0xaf, 0x36, 0xcc, 0xec, 0x1b, 0xea, 0x48, 0xfa, 0x2b, 0xa4, 0xc2,
            0xeb, 0x67, 0xef, 0x7f, 0x9e, 0xcb, 0x17, 0xed, 0x27, 0xd3, 0x8d, 0x27, 0xcd, 0xed,
            0xdf, 0xf4, 0x4c, 0x81, 0x37, 0xbe,
        ];

        let h1 = [
            0x98, 0xcd, 0x53, 0x13, 0x28, 0x3a, 0xaf, 0x5d, 0xb1, 0xb3, 0xba, 0x86, 0x11, 0xfe,
            0x60, 0x70, 0xd1, 0x9e, 0x60, 0x5d, 0xe4, 0x07, 0x8c, 0x38, 0xdf, 0x36, 0x01, 0x9f,
            0xba, 0xad, 0x0b, 0xd2, 0x8d, 0xd0, 0x90, 0xfd, 0x24, 0xed, 0x27, 0xf7, 0xf4, 0xd2,
            0x2d, 0x5f, 0xf5, 0xde, 0xa7, 0xd4,
        ];
        let h2 = [
            0xa3, 0x1f, 0xbe, 0x20, 0xc5, 0xc1, 0x35, 0xbc, 0xaa, 0x8d, 0x9f, 0xc4, 0xe4, 0xac,
            0x66, 0x5c, 0xc6, 0xdb, 0x02, 0x26, 0xf3, 0x5e, 0x73, 0x75, 0x07, 0xe8, 0x03, 0x04,
            0x40, 0x93, 0xf3, 0x76, 0x97, 0xa9, 0xd4, 0x52, 0x49, 0x0a, 0x97, 0x0e, 0xea, 0x6f,
            0x9a, 0xd6, 0xc3, 0xdc, 0xaa, 0x3a,
        ];
        let h3 = [
            0xb4, 0x79, 0x26, 0x34, 0x45, 0xf4, 0xd2, 0x10, 0x89, 0x65, 0xa9, 0x08, 0x6f, 0x9d,
            0x1f, 0xdc, 0x8c, 0xde, 0x77, 0xd1, 0x4a, 0x91, 0xc8, 0x56, 0x76, 0x95, 0x21, 0xad,
            0x33, 0x44, 0x75, 0x4c, 0xc5, 0xce, 0x90, 0xd9, 0xbc, 0x4c, 0x69, 0x6d, 0xff, 0xbc,
            0x9e, 0xf1, 0xd6, 0xad, 0x1b, 0x62,
        ];
        let h4 = [
            0xac, 0x04, 0x01, 0x76, 0x6d, 0x21, 0x28, 0xd4, 0x79, 0x1d, 0x92, 0x25, 0x57, 0xc7,
            0xb4, 0xd1, 0xae, 0x9a, 0x9b, 0x50, 0x8c, 0xe2, 0x66, 0x57, 0x52, 0x44, 0xa8, 0xd6,
            0xf3, 0x21, 0x10, 0xd7, 0xb0, 0xb7, 0x55, 0x7b, 0x77, 0x60, 0x48, 0x69, 0x63, 0x3b,
            0xb4, 0x9a, 0xfb, 0xe2, 0x00, 0x35,
        ];
        let h5 = [
            0xb9, 0x5d, 0x28, 0x98, 0x37, 0x0e, 0xbc, 0x54, 0x28, 0x57, 0x74, 0x6a, 0x31, 0x6c,
            0xe3, 0x2f, 0xa5, 0x15, 0x1c, 0x31, 0xf9, 0xb5, 0x79, 0x15, 0xe3, 0x08, 0xee, 0x9d,
            0x1d, 0xe7, 0xdb, 0x69, 0x12, 0x7d, 0x91, 0x9e, 0x98, 0x4e, 0xa0, 0x74, 0x7f, 0x52,
            0x23, 0x82, 0x1b, 0x59, 0x63, 0x35,
        ];
        let h6 = [
            0x8f, 0x19, 0x35, 0x9a, 0xe6, 0xee, 0x50, 0x81, 0x57, 0x49, 0x2c, 0x06, 0x76, 0x5b,
            0x7d, 0xf0, 0x9e, 0x2e, 0x5a, 0xd5, 0x91, 0x11, 0x57, 0x42, 0xf2, 0xde, 0x9c, 0x08,
            0x57, 0x2b, 0xb2, 0x84, 0x5c, 0xbf, 0x03, 0xfd, 0x7e, 0x23, 0xb7, 0xf0, 0x31, 0xed,
            0x9c, 0x75, 0x64, 0xe5, 0x2f, 0x39,
        ];
        let h7 = [
            0xab, 0xc9, 0x14, 0xab, 0xe2, 0x92, 0x63, 0x24, 0xb2, 0xc8, 0x48, 0xe8, 0xa4, 0x11,
            0xa2, 0xb6, 0xdf, 0x18, 0xcb, 0xe7, 0x75, 0x8d, 0xb8, 0x64, 0x41, 0x45, 0xfe, 0xfb,
            0x0b, 0xf0, 0xa2, 0xd5, 0x58, 0xa8, 0xc9, 0x94, 0x6b, 0xd3, 0x5e, 0x00, 0xc6, 0x9d,
            0x16, 0x7a, 0xad, 0xf3, 0x04, 0xc1,
        ];
        let h8 = [
            0x80, 0x75, 0x5b, 0x3e, 0xb0, 0xdd, 0x42, 0x49, 0xcb, 0xef, 0xd2, 0x0f, 0x17, 0x7c,
            0xee, 0x88, 0xe0, 0x76, 0x1c, 0x06, 0x6b, 0x71, 0x79, 0x48, 0x25, 0xc9, 0x99, 0x7b,
            0x55, 0x1f, 0x24, 0x05, 0x1c, 0x35, 0x25, 0x67, 0xba, 0x6c, 0x01, 0xe5, 0x7a, 0xc7,
            0x5d, 0xff, 0x76, 0x3e, 0xaa, 0x17,
        ];
        let h9 = [
            0x82, 0x70, 0x1e, 0xb9, 0x80, 0x70, 0x72, 0x8e, 0x17, 0x69, 0x52, 0x5e, 0x73, 0xab,
            0xff, 0x17, 0x83, 0xce, 0xdc, 0x36, 0x4a, 0xdb, 0x20, 0xc0, 0x5c, 0x89, 0x7a, 0x62,
            0xf2, 0xab, 0x29, 0x27, 0xf8, 0x6f, 0x11, 0x8d, 0xcb, 0x78, 0x19, 0xa7, 0xb2, 0x18,
            0xd8, 0xf3, 0xfe, 0xe4, 0xbd, 0x7f,
        ];
        let h10 = [
            0xa1, 0xf2, 0x29, 0x54, 0x04, 0x74, 0xf4, 0xd6, 0xf1, 0x13, 0x47, 0x61, 0xb9, 0x2b,
            0x78, 0x81, 0x28, 0xc7, 0xac, 0x8d, 0xc9, 0xb0, 0xc5, 0x2d, 0x59, 0x49, 0x31, 0x32,
            0x67, 0x96, 0x73, 0x03, 0x2a, 0xc7, 0xdb, 0x3f, 0xb3, 0xd7, 0x9b, 0x46, 0xb1, 0x3c,
            0x1c, 0x41, 0xee, 0x49, 0x5b, 0xca,
        ];

        let affine_q1: G1Affine = generators[0].into();
        assert_eq!(affine_q1.to_compressed(), q1);

        let affine_h1: G1Affine = generators[1].into();
        assert_eq!(affine_h1.to_compressed(), h1);

        let affine_h2: G1Affine = generators[2].into();
        assert_eq!(affine_h2.to_compressed(), h2);

        let affine_h3: G1Affine = generators[3].into();
        assert_eq!(affine_h3.to_compressed(), h3);

        let affine_h4: G1Affine = generators[4].into();
        assert_eq!(affine_h4.to_compressed(), h4);

        let affine_h5: G1Affine = generators[5].into();
        assert_eq!(affine_h5.to_compressed(), h5);

        let affine_h6: G1Affine = generators[6].into();
        assert_eq!(affine_h6.to_compressed(), h6);

        let affine_h7: G1Affine = generators[7].into();
        assert_eq!(affine_h7.to_compressed(), h7);

        let affine_h8: G1Affine = generators[8].into();
        assert_eq!(affine_h8.to_compressed(), h8);

        let affine_h9: G1Affine = generators[9].into();
        assert_eq!(affine_h9.to_compressed(), h9);

        let affine_h10: G1Affine = generators[10].into();
        assert_eq!(affine_h10.to_compressed(), h10);
    }

    #[test]
    fn messages_to_scalars_test_vec_1() {
        let dst = b"BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_H2G_HM2S_";
        let input = vec![M1, M2, M3, M4, M5, M6, M7, M8, M9, M10];
        let message_scalars = messages_to_scalars(&input, Some(dst));

        let mut msg_scalar_0 = [
            0x1c, 0xb5, 0xbb, 0x86, 0x11, 0x4b, 0x34, 0xdc, 0x43, 0x8a, 0x91, 0x16, 0x17, 0x65,
            0x5a, 0x1d, 0xb5, 0x95, 0xab, 0xaf, 0xac, 0x92, 0xf4, 0x7c, 0x50, 0x01, 0x79, 0x9c,
            0xf6, 0x24, 0xb4, 0x30,
        ];
        msg_scalar_0.reverse();
        let mut msg_scalar_1 = [
            0x15, 0x42, 0x49, 0xd5, 0x03, 0xc0, 0x93, 0xac, 0x2d, 0xf5, 0x16, 0xd4, 0xbb, 0x88,
            0xb5, 0x10, 0xd5, 0x4f, 0xd9, 0x7e, 0x8d, 0x71, 0x21, 0xae, 0xde, 0x42, 0x0a, 0x25,
            0xd9, 0x52, 0x19, 0x52,
        ];
        msg_scalar_1.reverse();
        let mut msg_scalar_2 = [
            0x0c, 0x7c, 0x4c, 0x85, 0xcd, 0xab, 0x32, 0xe6, 0xfd, 0xb0, 0xde, 0x26, 0x7b, 0x16,
            0xfa, 0x32, 0x12, 0x73, 0x3d, 0x4e, 0x3a, 0x3f, 0x0d, 0x0f, 0x75, 0x16, 0x57, 0x57,
            0x8b, 0x26, 0xfe, 0x22,
        ];
        msg_scalar_2.reverse();
        let mut msg_scalar_3 = [
            0x4a, 0x19, 0x6d, 0xea, 0xfe, 0xe5, 0xc2, 0x3f, 0x63, 0x01, 0x56, 0xae, 0x13, 0xbe,
            0x3e, 0x46, 0xe5, 0x3b, 0x7e, 0x39, 0x09, 0x4d, 0x22, 0x87, 0x7b, 0x8c, 0xba, 0x7f,
            0x14, 0x64, 0x08, 0x88,
        ];
        msg_scalar_3.reverse();
        let mut msg_scalar_4 = [
            0x34, 0xc5, 0xea, 0x4f, 0x2b, 0xa4, 0x91, 0x17, 0x01, 0x5a, 0x02, 0xc7, 0x11, 0xbb,
            0x17, 0x3c, 0x11, 0xb0, 0x6b, 0x3f, 0x15, 0x71, 0xb8, 0x8a, 0x29, 0x52, 0xb9, 0x3d,
            0x0e, 0xd4, 0xcf, 0x7e,
        ];
        msg_scalar_4.reverse();
        let mut msg_scalar_5 = [
            0x40, 0x45, 0xb3, 0x9b, 0x83, 0x05, 0x5c, 0xd5, 0x7a, 0x4d, 0x02, 0x03, 0xe1, 0x66,
            0x08, 0x00, 0xfa, 0xbe, 0x43, 0x40, 0x04, 0xdb, 0xdc, 0x87, 0x30, 0xc2, 0x1c, 0xe3,
            0xf0, 0x04, 0x8b, 0x08,
        ];
        msg_scalar_5.reverse();
        let mut msg_scalar_6 = [
            0x06, 0x46, 0x21, 0xda, 0x43, 0x77, 0xb6, 0xb1, 0xd0, 0x5e, 0xcc, 0x37, 0xcf, 0x3b,
            0x9d, 0xfc, 0x94, 0xb9, 0x49, 0x8d, 0x70, 0x13, 0xdc, 0x5c, 0x4a, 0x82, 0xbf, 0x3b,
            0xb1, 0x75, 0x07, 0x43,
        ];
        msg_scalar_6.reverse();
        let mut msg_scalar_7 = [
            0x34, 0xac, 0x91, 0x96, 0xac, 0xe0, 0xa3, 0x7e, 0x14, 0x7e, 0x32, 0x31, 0x9e, 0xa9,
            0xb3, 0xd8, 0xcc, 0x7d, 0x21, 0x87, 0x0d, 0x3c, 0x3b, 0xa0, 0x71, 0x24, 0x68, 0x59,
            0xcc, 0xa4, 0x9b, 0x02,
        ];
        msg_scalar_7.reverse();
        let mut msg_scalar_8 = [
            0x57, 0xeb, 0x93, 0xf4, 0x17, 0xc4, 0x32, 0x00, 0xe9, 0x78, 0x4f, 0xa5, 0xea, 0x5a,
            0x59, 0x16, 0x8d, 0x3d, 0xbc, 0x38, 0xdf, 0x70, 0x7a, 0x13, 0xbb, 0x59, 0x7c, 0x87,
            0x1b, 0x2a, 0x5f, 0x74,
        ];
        msg_scalar_8.reverse();
        let mut msg_scalar_9 = [
            0x08, 0xe3, 0xaf, 0xeb, 0x2b, 0x4f, 0x2b, 0x5f, 0x90, 0x79, 0x24, 0xef, 0x42, 0x85,
            0x66, 0x16, 0xe6, 0xf2, 0xd5, 0xf1, 0xfb, 0x37, 0x37, 0x36, 0xdb, 0x1c, 0xca, 0x32,
            0x70, 0x7a, 0x7d, 0x16,
        ];
        msg_scalar_9.reverse();

        assert_eq!(message_scalars[0].to_bytes(), msg_scalar_0);
        assert_eq!(message_scalars[1].to_bytes(), msg_scalar_1);
        assert_eq!(message_scalars[2].to_bytes(), msg_scalar_2);
        assert_eq!(message_scalars[3].to_bytes(), msg_scalar_3);
        assert_eq!(message_scalars[4].to_bytes(), msg_scalar_4);
        assert_eq!(message_scalars[5].to_bytes(), msg_scalar_5);
        assert_eq!(message_scalars[6].to_bytes(), msg_scalar_6);
        assert_eq!(message_scalars[7].to_bytes(), msg_scalar_7);
        assert_eq!(message_scalars[8].to_bytes(), msg_scalar_8);
        assert_eq!(message_scalars[9].to_bytes(), msg_scalar_9);
    }

    #[test]
    fn key_gen_test_vec_1() {
        let key_material = [
            0x74, 0x68, 0x69, 0x73, 0x2d, 0x49, 0x53, 0x2d, 0x6a, 0x75, 0x73, 0x74, 0x2d, 0x61,
            0x6e, 0x2d, 0x54, 0x65, 0x73, 0x74, 0x2d, 0x49, 0x4b, 0x4d, 0x2d, 0x74, 0x6f, 0x2d,
            0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x2d, 0x24, 0x65, 0x28, 0x72, 0x40,
            0x74, 0x23, 0x2d, 0x6b, 0x65, 0x79,
        ];

        let key_info = [
            0x74, 0x68, 0x69, 0x73, 0x2d, 0x49, 0x53, 0x2d, 0x73, 0x6f, 0x6d, 0x65, 0x2d, 0x6b,
            0x65, 0x79, 0x2d, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2d, 0x74, 0x6f,
            0x2d, 0x62, 0x65, 0x2d, 0x75, 0x73, 0x65, 0x64, 0x2d, 0x69, 0x6e, 0x2d, 0x74, 0x65,
            0x73, 0x74, 0x2d, 0x6b, 0x65, 0x79, 0x2d, 0x67, 0x65, 0x6e,
        ];

        let key_dst = b"BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_H2G_HM2S_KEYGEN_DST_";
        let key_dst_b = [
            0x42, 0x42, 0x53, 0x5f, 0x42, 0x4c, 0x53, 0x31, 0x32, 0x33, 0x38, 0x31, 0x47, 0x31,
            0x5f, 0x58, 0x4d, 0x44, 0x3a, 0x53, 0x48, 0x41, 0x2d, 0x32, 0x35, 0x36, 0x5f, 0x53,
            0x53, 0x57, 0x55, 0x5f, 0x52, 0x4f, 0x5f, 0x48, 0x32, 0x47, 0x5f, 0x48, 0x4d, 0x32,
            0x53, 0x5f, 0x4b, 0x45, 0x59, 0x47, 0x45, 0x4e, 0x5f, 0x44, 0x53, 0x54, 0x5f,
        ];

        assert_eq!(key_dst, &key_dst_b);

        let sk = key_gen(&key_material, &key_info, Some(key_dst));

        let mut expected_sk = [
            0x60, 0xe5, 0x51, 0x10, 0xf7, 0x68, 0x83, 0xa1, 0x3d, 0x03, 0x0b, 0x2f, 0x6b, 0xd1,
            0x18, 0x83, 0x42, 0x2d, 0x5a, 0xbd, 0xe7, 0x17, 0x56, 0x9f, 0xc0, 0x73, 0x1f, 0x51,
            0x23, 0x71, 0x69, 0xfc,
        ];
        expected_sk.reverse();

        assert_eq!(sk.to_bytes(), expected_sk);

        let pk = sk_to_pk(&sk);

        let expected_pk = [
            0xa8, 0x20, 0xf2, 0x30, 0xf6, 0xae, 0x38, 0x50, 0x3b, 0x86, 0xc7, 0x0d, 0xc5, 0x0b,
            0x61, 0xc5, 0x8a, 0x77, 0xe4, 0x5c, 0x39, 0xab, 0x25, 0xc0, 0x65, 0x2b, 0xba, 0xa8,
            0xfa, 0x13, 0x6f, 0x28, 0x51, 0xbd, 0x47, 0x81, 0xc9, 0xdc, 0xde, 0x39, 0xfc, 0x9d,
            0x1d, 0x52, 0xc9, 0xe6, 0x02, 0x68, 0x06, 0x1e, 0x7d, 0x76, 0x32, 0x17, 0x1d, 0x91,
            0xaa, 0x8d, 0x46, 0x0a, 0xce, 0xe0, 0xe9, 0x6f, 0x1e, 0x7c, 0x4c, 0xfb, 0x12, 0xd3,
            0xff, 0x9a, 0xb5, 0xd5, 0xdc, 0x91, 0xc2, 0x77, 0xdb, 0x75, 0xc8, 0x45, 0xd6, 0x49,
            0xef, 0x3c, 0x4f, 0x63, 0xae, 0xbc, 0x36, 0x4c, 0xd5, 0x5d, 0xed, 0x0c,
        ];

        assert_eq!(pk, expected_pk);
    }

    #[test]
    fn expand_message_xmd_test_vec_1() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"";
        let msg_len = 0x20;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0x68, 0xa9, 0x85, 0xb8, 0x7e, 0xb6, 0xb4, 0x69, 0x52, 0x12, 0x89, 0x11, 0xf2, 0xa4,
            0x41, 0x2b, 0xbc, 0x30, 0x2a, 0x9d, 0x75, 0x96, 0x67, 0xf8, 0x7f, 0x7a, 0x21, 0xd8,
            0x03, 0xf0, 0x72, 0x35,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn expand_message_xmd_test_vec_2() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"abc";
        let msg_len = 0x20;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0xd8, 0xcc, 0xab, 0x23, 0xb5, 0x98, 0x5c, 0xce, 0xa8, 0x65, 0xc6, 0xc9, 0x7b, 0x6e,
            0x5b, 0x83, 0x50, 0xe7, 0x94, 0xe6, 0x03, 0xb4, 0xb9, 0x79, 0x02, 0xf5, 0x3a, 0x8a,
            0x0d, 0x60, 0x56, 0x15,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn expand_message_xmd_test_vec_3() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"abcdef0123456789";
        let msg_len = 0x20;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0xef, 0xf3, 0x14, 0x87, 0xc7, 0x70, 0xa8, 0x93, 0xcf, 0xb3, 0x6f, 0x91, 0x2f, 0xbf,
            0xcb, 0xff, 0x40, 0xd5, 0x66, 0x17, 0x71, 0xca, 0x4b, 0x2c, 0xb4, 0xea, 0xfe, 0x52,
            0x43, 0x33, 0xf5, 0xc1,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn expand_message_xmd_test_vec_4() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq";
        let msg_len = 0x20;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0xb2, 0x3a, 0x1d, 0x2b, 0x4d, 0x97, 0xb2, 0xef, 0x77, 0x85, 0x56, 0x2a, 0x7e, 0x8b,
            0xac, 0x7e, 0xed, 0x54, 0xed, 0x6e, 0x97, 0xe2, 0x9a, 0xa5, 0x1b, 0xfe, 0x3f, 0x12,
            0xdd, 0xad, 0x1f, 0xf9,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn expand_message_xmd_test_vec_5() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
        let msg_len = 0x20;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0x46, 0x23, 0x22, 0x7b, 0xcc, 0x01, 0x29, 0x3b, 0x8c, 0x13, 0x0b, 0xf7, 0x71, 0xda,
            0x8c, 0x29, 0x8d, 0xed, 0xe7, 0x38, 0x32, 0x43, 0xdc, 0x09, 0x93, 0xd2, 0xd9, 0x48,
            0x23, 0x95, 0x8c, 0x4c,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn expand_message_xmd_test_vec_6() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"";
        let msg_len = 0x80;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0xaf, 0x84, 0xc2, 0x7c, 0xcf, 0xd4, 0x5d, 0x41, 0x91, 0x4f, 0xdf, 0xf5, 0xdf, 0x25,
            0x29, 0x3e, 0x22, 0x1a, 0xfc, 0x53, 0xd8, 0xad, 0x2a, 0xc0, 0x6d, 0x5e, 0x3e, 0x29,
            0x48, 0x5d, 0xad, 0xbe, 0xe0, 0xd1, 0x21, 0x58, 0x77, 0x13, 0xa3, 0xe0, 0xdd, 0x4d,
            0x5e, 0x69, 0xe9, 0x3e, 0xb7, 0xcd, 0x4f, 0x5d, 0xf4, 0xcd, 0x10, 0x3e, 0x18, 0x8c,
            0xf6, 0x0c, 0xb0, 0x2e, 0xdc, 0x3e, 0xdf, 0x18, 0xed, 0xa8, 0x57, 0x6c, 0x41, 0x2b,
            0x18, 0xff, 0xb6, 0x58, 0xe3, 0xdd, 0x6e, 0xc8, 0x49, 0x46, 0x9b, 0x97, 0x9d, 0x44,
            0x4c, 0xf7, 0xb2, 0x69, 0x11, 0xa0, 0x8e, 0x63, 0xcf, 0x31, 0xf9, 0xdc, 0xc5, 0x41,
            0x70, 0x8d, 0x34, 0x91, 0x18, 0x44, 0x72, 0xc2, 0xc2, 0x9b, 0xb7, 0x49, 0xd4, 0x28,
            0x6b, 0x00, 0x4c, 0xeb, 0x5e, 0xe6, 0xb9, 0xa7, 0xfa, 0x5b, 0x64, 0x6c, 0x99, 0x3f,
            0x0c, 0xed,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn expand_message_xmd_test_vec_7() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"abc";
        let msg_len = 0x80;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0xab, 0xba, 0x86, 0xa6, 0x12, 0x9e, 0x36, 0x6f, 0xc8, 0x77, 0xaa, 0xb3, 0x2f, 0xc4,
            0xff, 0xc7, 0x01, 0x20, 0xd8, 0x99, 0x6c, 0x88, 0xae, 0xe2, 0xfe, 0x4b, 0x32, 0xd6,
            0xc7, 0xb6, 0x43, 0x7a, 0x64, 0x7e, 0x6c, 0x31, 0x63, 0xd4, 0x0b, 0x76, 0xa7, 0x3c,
            0xf6, 0xa5, 0x67, 0x4e, 0xf1, 0xd8, 0x90, 0xf9, 0x5b, 0x66, 0x4e, 0xe0, 0xaf, 0xa5,
            0x35, 0x9a, 0x5c, 0x4e, 0x07, 0x98, 0x56, 0x35, 0xbb, 0xec, 0xba, 0xc6, 0x5d, 0x74,
            0x7d, 0x3d, 0x2d, 0xa7, 0xec, 0x2b, 0x82, 0x21, 0xb1, 0x7b, 0x0c, 0xa9, 0xdc, 0x8a,
            0x1a, 0xc1, 0xc0, 0x7e, 0xa6, 0xa1, 0xe6, 0x05, 0x83, 0xe2, 0xcb, 0x00, 0x05, 0x8e,
            0x77, 0xb7, 0xb7, 0x2a, 0x29, 0x84, 0x25, 0xcd, 0x1b, 0x94, 0x1a, 0xd4, 0xec, 0x65,
            0xe8, 0xaf, 0xc5, 0x03, 0x03, 0xa2, 0x2c, 0x0f, 0x99, 0xb0, 0x50, 0x9b, 0x4c, 0x89,
            0x5f, 0x40,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn expand_message_xmd_test_vec_8() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"abcdef0123456789";
        let msg_len = 0x80;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0xef, 0x90, 0x4a, 0x29, 0xbf, 0xfc, 0x4c, 0xf9, 0xee, 0x82, 0x83, 0x24, 0x51, 0xc9,
            0x46, 0xac, 0x3c, 0x8f, 0x80, 0x58, 0xae, 0x97, 0xd8, 0xd6, 0x29, 0x83, 0x1a, 0x74,
            0xc6, 0x57, 0x2b, 0xd9, 0xeb, 0xd0, 0xdf, 0x63, 0x5c, 0xd1, 0xf2, 0x08, 0xe2, 0x03,
            0x8e, 0x76, 0x0c, 0x49, 0x94, 0x98, 0x4c, 0xe7, 0x3f, 0x0d, 0x55, 0xea, 0x9f, 0x22,
            0xaf, 0x83, 0xba, 0x47, 0x34, 0x56, 0x9d, 0x4b, 0xc9, 0x5e, 0x18, 0x35, 0x0f, 0x74,
            0x0c, 0x07, 0xee, 0xf6, 0x53, 0xcb, 0xb9, 0xf8, 0x79, 0x10, 0xd8, 0x33, 0x75, 0x18,
            0x25, 0xf0, 0xeb, 0xef, 0xa1, 0xab, 0xe5, 0x42, 0x0b, 0xb5, 0x2b, 0xe1, 0x4c, 0xf4,
            0x89, 0xb3, 0x7f, 0xe1, 0xa7, 0x2f, 0x7d, 0xe2, 0xd1, 0x0b, 0xe4, 0x53, 0xb2, 0xc9,
            0xd9, 0xeb, 0x20, 0xc7, 0xe3, 0xf6, 0xed, 0xc5, 0xa6, 0x06, 0x29, 0x17, 0x8d, 0x94,
            0x78, 0xdf,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn expand_message_xmd_test_vec_9() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"q128_qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq";
        let msg_len = 0x80;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0x80, 0xbe, 0x10, 0x7d, 0x08, 0x84, 0xf0, 0xd8, 0x81, 0xbb, 0x46, 0x03, 0x22, 0xf0,
            0x44, 0x3d, 0x38, 0xbd, 0x22, 0x2d, 0xb8, 0xbd, 0x0b, 0x0a, 0x53, 0x12, 0xa6, 0xfe,
            0xdb, 0x49, 0xc1, 0xbb, 0xd8, 0x8f, 0xd7, 0x5d, 0x8b, 0x9a, 0x09, 0x48, 0x6c, 0x60,
            0x12, 0x3d, 0xfa, 0x1d, 0x73, 0xc1, 0xcc, 0x31, 0x69, 0x76, 0x1b, 0x17, 0x47, 0x6d,
            0x3c, 0x6b, 0x7c, 0xbb, 0xd7, 0x27, 0xac, 0xd0, 0xe2, 0xc9, 0x42, 0xf4, 0xdd, 0x96,
            0xae, 0x3d, 0xa5, 0xde, 0x36, 0x8d, 0x26, 0xb3, 0x22, 0x86, 0xe3, 0x2d, 0xe7, 0xe5,
            0xa8, 0xcb, 0x29, 0x49, 0xf8, 0x66, 0xa0, 0xb8, 0x0c, 0x58, 0x11, 0x6b, 0x29, 0xfa,
            0x7f, 0xab, 0xb3, 0xea, 0x7d, 0x52, 0x0e, 0xe6, 0x03, 0xe0, 0xc2, 0x5b, 0xca, 0xf0,
            0xb9, 0xa5, 0xe9, 0x2e, 0xc6, 0xa1, 0xfe, 0x4e, 0x03, 0x91, 0xd1, 0xcd, 0xbc, 0xe8,
            0xc6, 0x8a,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn expand_message_xmd_test_vec_10() {
        let dst = b"QUUX-V01-CS02-with-expander-SHA256-128";
        let msg = b"a512_aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
        let msg_len = 0x80;

        let result = expand_message_xmd(msg, dst, msg_len);

        let expected = [
            0x54, 0x6a, 0xff, 0x54, 0x44, 0xb5, 0xb7, 0x9a, 0xa6, 0x14, 0x8b, 0xd8, 0x17, 0x28,
            0x70, 0x4c, 0x32, 0xde, 0xcb, 0x73, 0xa3, 0xba, 0x76, 0xe9, 0xe7, 0x58, 0x85, 0xca,
            0xd9, 0xde, 0xf1, 0xd0, 0x6d, 0x67, 0x92, 0xf8, 0xa7, 0xd1, 0x27, 0x94, 0xe9, 0x0e,
            0xfe, 0xd8, 0x17, 0xd9, 0x69, 0x20, 0xd7, 0x28, 0x89, 0x6a, 0x45, 0x10, 0x86, 0x43,
            0x70, 0xc2, 0x07, 0xf9, 0x9b, 0xd4, 0xa6, 0x08, 0xea, 0x12, 0x17, 0x00, 0xef, 0x01,
            0xed, 0x87, 0x97, 0x45, 0xee, 0x3e, 0x4c, 0xee, 0xf7, 0x77, 0xed, 0xa6, 0xd9, 0xe5,
            0xe3, 0x8b, 0x90, 0xc8, 0x6e, 0xa6, 0xfb, 0x0b, 0x36, 0x50, 0x4b, 0xa4, 0xa4, 0x5d,
            0x22, 0xe8, 0x6f, 0x6d, 0xb5, 0xdd, 0x43, 0xd9, 0x8a, 0x29, 0x4b, 0xeb, 0xb9, 0x12,
            0x5d, 0x5b, 0x79, 0x4e, 0x9d, 0x2a, 0x81, 0x18, 0x10, 0x66, 0xeb, 0x95, 0x49, 0x66,
            0xa4, 0x87,
        ];

        assert_eq!(result, expected);
    }

    #[test]
    fn hash_to_scalar_test_vec_1() {
        let msg = [
            0x98, 0x72, 0xad, 0x08, 0x9e, 0x45, 0x2c, 0x7b, 0x6e, 0x28, 0x3d, 0xfa, 0xc2, 0xa8,
            0x0d, 0x58, 0xe8, 0xd0, 0xff, 0x71, 0xcc, 0x4d, 0x5e, 0x31, 0x0a, 0x1d, 0xeb, 0xdd,
            0xa4, 0xa4, 0x5f, 0x02,
        ];

        let dst = [
            0x42, 0x42, 0x53, 0x5f, 0x42, 0x4c, 0x53, 0x31, 0x32, 0x33, 0x38, 0x31, 0x47, 0x31,
            0x5f, 0x58, 0x4d, 0x44, 0x3a, 0x53, 0x48, 0x41, 0x2d, 0x32, 0x35, 0x36, 0x5f, 0x53,
            0x53, 0x57, 0x55, 0x5f, 0x52, 0x4f, 0x5f, 0x48, 0x32, 0x47, 0x5f, 0x48, 0x4d, 0x32,
            0x53, 0x5f, 0x48, 0x32, 0x53, 0x5f,
        ];

        let result = hash_to_scalar(&msg, &dst);

        let mut bytes = [
            0x0f, 0x90, 0xcb, 0xee, 0x27, 0xbe, 0xb2, 0x14, 0xe6, 0x54, 0x5b, 0xec, 0xb8, 0x40,
            0x46, 0x40, 0xd3, 0x61, 0x2d, 0xa5, 0xd6, 0x75, 0x8d, 0xff, 0xec, 0xcd, 0x77, 0xed,
            0x71, 0x69, 0x80, 0x7c,
        ];
        bytes.reverse();

        assert_eq!(result.to_bytes(), bytes);
    }
}
